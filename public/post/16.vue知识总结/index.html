<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>vue知识总结 - Huyu&#39; Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="huyu" /><meta name="description" content="1、vue 修改数据页面不重新渲染 vue2是用过Object.defineProperty实现数据响应式, 组件初始化时，对 data 中的 item 进行递归遍历" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.105.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/16.vue%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.a7c3372b17782ac7f2fa8c3cd7f2508f64a1456f433e3f82db4be08802b35f05.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="vue知识总结" />
<meta property="og:description" content="1、vue 修改数据页面不重新渲染 vue2是用过Object.defineProperty实现数据响应式, 组件初始化时，对 data 中的 item 进行递归遍历" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/16.vue%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-11T21:02:13+00:00" />
<meta property="article:modified_time" content="2022-02-11T21:02:13+00:00" />

<meta itemprop="name" content="vue知识总结">
<meta itemprop="description" content="1、vue 修改数据页面不重新渲染 vue2是用过Object.defineProperty实现数据响应式, 组件初始化时，对 data 中的 item 进行递归遍历"><meta itemprop="datePublished" content="2022-02-11T21:02:13+00:00" />
<meta itemprop="dateModified" content="2022-02-11T21:02:13+00:00" />
<meta itemprop="wordCount" content="12175">
<meta itemprop="keywords" content="vue," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="vue知识总结"/>
<meta name="twitter:description" content="1、vue 修改数据页面不重新渲染 vue2是用过Object.defineProperty实现数据响应式, 组件初始化时，对 data 中的 item 进行递归遍历"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Huyu&#39; Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Huyu&#39; Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">vue知识总结</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-11 </span>
        <div class="post-category">
            <a href="/categories/%E9%9D%A2%E8%AF%95/"> 面试 </a>
            </div>
          <span class="more-meta"> 约 12175 字 </span>
          <span class="more-meta"> 预计阅读 25 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h4 id="1vue-修改数据页面不重新渲染">1、vue 修改数据页面不重新渲染</h4>
<blockquote>
<p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式, 组件初始化时，对 data 中的 item 进行递归遍历，对 item 的每一个属性进行劫持，添加 set , get 方法。我们后来 新加的属性 ，并没有通过<code>Object.defineProperty</code>设置成响应式数据，修改后不会视图更新</p>
</blockquote>
<p><strong>通过数组索引号修改了数组，界面会不会相应更新？为什么？</strong></p>
<p>答：不会。vue 监听不到</p>
<p>vue 为什么没有提供 <code>arr[下标] = val</code> 变成响应式？</p>
<p>尤大：&ldquo;因为性能问题，性能代价和获得的用户体验收益不成正比&rdquo;</p>
<h6 id="数组对象的响应式-vue-里面是怎么处理的"><strong>数组/对象的响应式 ，vue 里面是怎么处理的？</strong></h6>
<p><strong>对象</strong>：使用了<code>Object.defineProperty</code>中的 get 和 set</p>
<blockquote>
<p>如何监测对象中的数据？
通过 setter 实现监视，且要在 new Vue 时就传⼊要监测的数据</p>
<ol>
<li>对象中后追加的属性，Vue 默认不做响应式处理</li>
<li>如需给后添加的属性做响应式，请使⽤如下 API：
<code>Vue.set(target,propertyName/index,value)</code>  <code>vm.$set(target,propertyName/index,value)</code></li>
</ol>
</blockquote>
<p><strong><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">数组</a></strong>： <code>Vue</code>重写了数组的原型，更准确的表达是<strong>拦截</strong>了数组的原型</p>
<blockquote>
<p>如何监测数组中的数据？
通过包裹数组更新元素的⽅法实现，本质就是做了两件事：</p>
<ol>
<li>
<p>调⽤原⽣对应的⽅法对数组进⾏更新</p>
</li>
<li>
<p>重新解析模板，进⽽更新⻚⾯</p>
</li>
<li>
<p>在 Vue 修改数组中的某个元素⼀定要⽤如下⽅法：</p>
<ol>
<li>使 ⽤ 这 些 API ：
<code>push() pop() shift() unshift() splice() sort() reverse()</code></li>
<li><code>Vue.set()</code> 或 <code>vm.$set()</code></li>
<li>覆盖整个数组</li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>为什么对象和数组要分开处理?</strong></p>
<blockquote>
<p><code>对象</code>的属性通常比较少，对每一个属性都劫持<code>set和get</code>，并不会消耗很多性能</p>
<p><code>数组</code>有可能有成千上万个元素，如果每一个元素都劫持<code>set和get</code>，无疑消耗太多性能了</p>
<p>所以<code>对象</code>通过<code>defineProperty</code>进行正常的劫持<code>set和get</code></p>
<p><code>数组</code>则通过<code>修改数组原型上的部分方法</code>，来实现<code>修改数组触发响应式</code></p>
</blockquote>
<h4 id="2生命周期">2、生命周期</h4>
<h5 id="vue-生命周期都有哪些">Vue 生命周期都有哪些？</h5>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期</th>
<th style="text-align:left">执行时机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>beforeCreate</code></td>
<td style="text-align:left">在组件实例被创建之初、组件的属性⽣效之前被调用</td>
</tr>
<tr>
<td style="text-align:center"><code>created</code></td>
<td style="text-align:left">在组件实例已创建完毕。此时属性也已绑定，但真实 DOM 还未⽣成，$el 还不可⽤</td>
</tr>
<tr>
<td style="text-align:center"><code>beforeMount</code></td>
<td style="text-align:left">在组件挂载开始之前被调⽤。相关的 render 函数⾸次被调⽤</td>
</tr>
<tr>
<td style="text-align:center"><code>mounted</code></td>
<td style="text-align:left">在 el 被新建的 vm.$el 替换并挂载到实例上之后被调用</td>
</tr>
<tr>
<td style="text-align:center"><code>beforeUpdate</code></td>
<td style="text-align:left">在组件数据更新之前调⽤。发⽣在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td style="text-align:center"><code>update</code></td>
<td style="text-align:left">在组件数据更新之后被调用</td>
</tr>
<tr>
<td style="text-align:center"><code>activited</code></td>
<td style="text-align:left">在组件被激活时调⽤（使用了 <code>&lt;keep-alive&gt;</code> 的情况下）</td>
</tr>
<tr>
<td style="text-align:center"><code>deactivated</code></td>
<td style="text-align:left">在组件被销毁时调⽤（使用了 <code>&lt;keep-alive&gt;</code> 的情况下）</td>
</tr>
<tr>
<td style="text-align:center"><code>beforeDestory</code></td>
<td style="text-align:left">在组件销毁前调⽤</td>
</tr>
<tr>
<td style="text-align:center"><code>destoryed</code></td>
<td style="text-align:left">在组件销毁后调⽤</td>
</tr>
</tbody>
</table>
<h5 id="父子组件生命周期执行顺序">父子组件生命周期执行顺序</h5>
<p><strong>加载渲染过程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">	<span class="o">-&gt;</span><span class="nx">父beforeCreate</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">父created</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">父beforeMount</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">子beforeCreate</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">子created</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">子beforeMount</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">子mounted</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="nx">父mounted</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>更新过程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">父beforeUpdate</span><span class="o">-&gt;</span><span class="nx">子beforeUpdate</span><span class="o">-&gt;</span><span class="nx">子updated</span><span class="o">-&gt;</span><span class="nx">父updated</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>销毁过程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">父beforeDestroy</span><span class="o">-&gt;</span><span class="nx">子beforeDestroy</span><span class="o">-&gt;</span><span class="nx">子destroyed</span><span class="o">-&gt;</span><span class="nx">父destroyed</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p>
<p><a href="https://juejin.cn/post/6844903641866829838#heading-11">https://juejin.cn/post/6844903641866829838#heading-11</a></p>
<p><a href="https://juejin.cn/post/7114252241166401573">https://juejin.cn/post/7114252241166401573</a></p>
<h4 id="3watch-和-computed-的区别">3、watch 和 computed 的区别</h4>
<p>官方文档：对于任何复杂逻辑，你都应当使用计算属性</p>
<p>扩展：<a href="https://blog.csdn.net/weixin_43638968/article/details/103593954">vue 中 Computed、Methods、Watch 区别</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">computed（计算属性）</th>
<th style="text-align:center">watch（监视属性/侦听器）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">根据你所依赖的数据动态显示新的计算结果<br />不用再 data 中声明，否则报错</td>
<td style="text-align:center">data 的数据监听回调,依赖 data 的数据变化<br />直接使用 data 声明的数据</td>
</tr>
<tr>
<td style="text-align:center">支持缓存</td>
<td style="text-align:center">不支持缓存</td>
</tr>
<tr>
<td style="text-align:center">不支持异步</td>
<td style="text-align:center">支持异步</td>
</tr>
<tr>
<td style="text-align:center">有 get 和 set 方法，当数据变化时，调用 set 方法</td>
<td style="text-align:center">可以深度监视 deep,加载就调用 immediate<br />监听的函数接收两个函数，newVal 和 oldVla</td>
</tr>
<tr>
<td style="text-align:center">当需要进行数值计算，并且依赖于其它数据时，用 computed</td>
<td style="text-align:center">在某个数据变化时做一些事情或需要异步操作时，用 watch</td>
</tr>
<tr>
<td style="text-align:center">computed 能做的</td>
<td style="text-align:center">watch 都能做到</td>
</tr>
</tbody>
</table>
<h4 id="4组件通信组件间传值">4、组件通信（组件间传值）</h4>
<blockquote>
<ul>
<li><code>props</code> <code>$emit</code></li>
<li><code>.sync</code> <code>v-model</code></li>
<li><code>$parent / $children</code> $parent 获取父组件的实例，任意调用父组件的方法，修改父组件的数据</li>
<li><code>ref</code> 父组件获取 子组件 实例，任意调用子组件的方法获取子组件的属性</li>
<li><code>provide / inject</code>prpvide 父组件内部提供数据 inject 嵌套的子组件可以注入数据</li>
<li><code>$attrs / $listeners</code> $attrs(没有被 props 接收的所有自定义属性) $listeners(可以获取所有的父组件传递过来的自定义事件)</li>
<li><code>eventBus</code> 定义一个事件总线 使用<code>$on</code> 绑定 <code>$emit</code> 触发</li>
<li><code>vuex</code></li>
<li>路由传参</li>
</ul>
</blockquote>
<p><a href="https://www.wpgdadatong.com/cn/blog/detail?BID=B3650">https://www.wpgdadatong.com/cn/blog/detail?BID=B3650</a></p>
<p><a href="https://juejin.cn/post/7110223595359436813">https://juejin.cn/post/7110223595359436813</a></p>
<h4 id="5nexttick">5、$nextTick</h4>
<p><strong>NextTick 是什么</strong></p>
<blockquote>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 修改数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;修改后的值&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 此时DOM还没有更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span> <span class="c1">// =&gt; &#39;原始的值&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">this</span><span class="p">.</span><span class="nx">$nextTick</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// DOM 更新了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span> <span class="c1">// =&gt; &#39;修改后的值&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>应用场景：因为 vue 是异步执行 dom 更新的，所以当你希望在更新数据之后，操作新的视图， 那么你的操作逻辑应写在 Vue.nextTick(callback) 的回调中，而这个回调会在dom 更新循环结束之后执行。 否则，因为异步更新 dom 的原因，如果你不是在 Vue.nextTick(callback) 的回调中执行操作新视图， 那么可能会发生意外。例如你在 created()钩子 是不能操作 dom 的，但你可以在此调接口更新数据， 如果你此时希望接口更新完毕数据后，接着调用操作 dom 的逻辑，那么最后将这部分操作 dom 的逻辑， 放置在Vue.nextTick(callback) 的回调函数中。</p>
</blockquote>
<h4 id="6修饰符">6、修饰符</h4>
<p>引用：https://juejin.cn/post/7026867875990208543#heading-22</p>
<h5 id="事件修饰符">事件修饰符</h5>
<p><code>stop</code></p>
<ul>
<li><code>stop</code>修饰符的作用是阻止冒泡</li>
</ul>
<p><code>prevent⭐</code></p>
<ul>
<li><code>prevent</code>修饰符的作用是<strong>阻止默认事件</strong>（例如 a 标签的跳转）</li>
</ul>
<p><code>capture</code></p>
<ul>
<li>事件流默认冒泡，使用 capture 进行捕获<strong>捕获</strong></li>
</ul>
<p><code>self</code></p>
<ul>
<li><code>self</code>修饰符作用是，只有点击<strong>事件绑定的本身</strong>才会触发事件</li>
</ul>
<p><code>once</code></p>
<ul>
<li><code>once</code>修饰符的作用是，事件<strong>只执行一次</strong></li>
</ul>
<p><code>native⭐</code></p>
<ul>
<li><code>native</code>修饰符是加在<strong>自定义组件</strong>的事件上，保证事件能执行</li>
<li><code>native</code>是用来是在父组件中给子组件绑定一个<strong>原生的事件</strong>，就将子组件变成了普通的 HTML 标签看待</li>
</ul>
<p><code>passive</code></p>
<ul>
<li>当我们在监听元素滚动事件的时候，会一直触发 onscroll 事件，在 pc 端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 onscroll 事件整了一个.lazy 修饰符</li>
</ul>
<h5 id="v-bind-修饰符">v-bind 修饰符</h5>
<p><code>sync⭐</code></p>
<ul>
<li>
<p>当<code>父组件</code>传值进<code>子组件</code>，子组件想要改变这个值时，可以这么做</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 父组件里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;</span><span class="nx">children</span> <span class="o">:</span><span class="nx">foo</span><span class="p">.</span><span class="nx">sync</span><span class="o">=</span><span class="s2">&#34;bar&#34;</span><span class="o">&gt;&lt;</span><span class="err">/children&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 子组件里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;update:foo&#39;</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p><code>camel</code></p>
<p><code>.camel</code> 修饰符允许在使用 DOM 模板时将 <code>v-bind</code> property 名称驼峰化，例如 SVG 的 <code>viewBox</code> property：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">svg</span> <span class="o">:</span><span class="nx">view</span><span class="o">-</span><span class="nx">box</span><span class="p">.</span><span class="nx">camel</span><span class="o">=</span><span class="s2">&#34;viewBox&#34;</span><span class="o">&gt;&lt;</span><span class="err">/svg&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="鼠标修饰符">鼠标修饰符</h5>
<p><code>left</code> <code>right</code> <code>middle</code></p>
<ul>
<li>这三个修饰符是鼠标的左中右按键触发的事件</li>
</ul>
<h5 id="表单相关修饰符">表单相关修饰符</h5>
<p><code>trim⭐</code></p>
<ul>
<li><code>trim</code>修饰符的作用类似于 JavaScript 中的<code>trim()</code>方法，作用是把<code>v-model</code>绑定的值的首尾空格给过滤掉。</li>
</ul>
<p><code>lazy</code></p>
<ul>
<li><code>lazy</code>修饰符作用是，改变输入框的值时 value 不会改变，当光标离开输入框时，<code>v-model</code>绑定的值 value 才会改变</li>
</ul>
<p><code>number</code></p>
<ul>
<li><code>number</code>修饰符的作用是将值转成数字，但是先输入字符串和先输入数字，是两种情况：</li>
</ul>
<blockquote>
<p>先输入数字的话，只取前面数字部分</p>
<p>先输入字母的话，<code>number</code>修饰符无效</p>
</blockquote>
<h5 id="系统修饰符">系统修饰符</h5>
<blockquote>
<p><code>.ctrl</code>、<code>.alt</code>、<code>.shift</code>、<code>.meta</code></p>
</blockquote>
<h5 id="按键修饰符">按键修饰符</h5>
<blockquote>
<p>配合键盘事件使用: <code>.enter</code> <code>.tab</code> <code>.delete</code> <code>.esc</code> <code>.space</code> <code>.up</code> <code>.down</code> <code>left</code>&hellip;&hellip;</p>
</blockquote>
<h4 id="7图片上传-todo">7、图片上传 TODO⭐⭐</h4>
<p><a href="https://juejin.cn/post/6844903507640713223">FileReader 与 URL.createObjectURL 实现图片、视频上传预览</a></p>
<p>event.target.files 就是用户上传的图片信息</p>
<p>配合 cropperjs 可以实现图片裁剪功能</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 如果接口要求 Content-Type 是 multipart/form-data
</span></span></span><span class="line"><span class="cl"><span class="c1">// 则你必须传递 FormData 对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="8v-for-和-v-if--v-if-和-v-show">8、v-for 和 v-if / v-if 和 v-show</h4>
<p><a href="https://juejin.cn/post/7106437556354416677"><strong>为什么 v-if 和 v-for 不能同时使用？</strong></a></p>
<ul>
<li>
<p>v-if 不能和 v-for 一起使用的原因是 v-for 的优先级比 v-if 高，一起使用会造成性能浪费</p>
</li>
<li>
<p>解决方案有两种，把 v-if 放在 v-for 的外层或者把需要 v-for 的属性先从计算属性中过滤一次</p>
</li>
<li>
<p>v-if 和 v-for 的优先级问题在 vue3 中不需要考虑，vue3 更新了 v-if 和 v-for 的优先级，使 v-if 的优先级高于 v-for</p>
</li>
</ul>
<p><strong>v-if 和 v-show</strong></p>
<p><code>v-show</code>隐藏则是为该元素添加<code>display:none</code>。<code>v-if</code>是将<code>dom</code>元素整个添加或删除</p>
<ul>
<li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li>
<li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li>
</ul>
<p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>
<p>如果需要非常频繁地切换，则使用 v-show 较好</p>
<p>如果在运行时条件很少改变，则使用 v-if 较好</p>
<h4 id="9vueuse">9、Vue.use()</h4>
<p><code>Vue.use</code>是用来安装插件的</p>
<p><strong>用法</strong>：Vue.use(plugin)</p>
<ul>
<li><strong>如果插件是一个对象</strong>，必须提供 <code>install</code> 方法。</li>
<li><strong>如果插件是一个函数，它会被作为 install 方法</strong>。install 方法调用时，<code>会将 Vue 作为参数传入</code>。</li>
<li>Vue.use(plugin)调用之后，插件的 install 方法就会默认接受到一个参数，这个参数就是 Vue</li>
</ul>
<p><strong>总结：Vue.use 是官方提供给开发者的一个 api，用来注册、安装类似 Vuex、vue-router、ElementUI 之类的插件的</strong></p>
<h4 id="10-跨域">10、 跨域</h4>
<blockquote>
<p>线上环境的跨域问题
1、cors &raquo; 后端加响应头 access-control-allow-origin: &lsquo;*&rsquo; 允许所有的页面请求
2、代理(主流方案)
开发环境 ：webpack的devServer进行代理，本地请求转发到接口 vue.config.js &gt; devServer &gt; proxy {}
线上环境： 服务器端使用 nginx 反向代理，拦截请求转发到线上接口, 解决跨域问题</p>
</blockquote>
<h5 id="什么是跨域"><strong>什么是跨域</strong></h5>
<blockquote>
<p>跨域问题是浏览器的<strong>同源策略</strong>所导致的</p>
<p>其中，<strong>域名、协议、端口号</strong>相同，称之为同源，如果不同，称之为跨源或<strong>跨域</strong></p>
</blockquote>
<p><strong>跨域常见的解决方法：</strong></p>
<ul>
<li><strong>代理</strong>，常用</li>
<li><strong>CORS</strong>，常用</li>
<li>JSONP</li>
</ul>
<h5 id="跨域解决方法-1-代理">跨域解决方法 1-代理</h5>
<blockquote>
<p>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域</p>
<p>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理</p>
</blockquote>
<p>在实际开发中，只需要对开发服务器稍加配置即可完成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// vue 的开发服务器代理配置
</span></span></span><span class="line"><span class="cl"><span class="c1">// vue.config.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">devServer</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 配置开发服务器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">proxy</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 配置代理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="s2">&#34;/api&#34;</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 若请求路径以 /api 开头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">target</span><span class="o">:</span> <span class="s2">&#34;http://dev.taobao.com&#34;</span><span class="p">,</span> <span class="c1">// 将其转发到 http://dev.taobao.com
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="跨域解决方法-2-cors">跨域解决方法 2-CORS</h5>
<p>阮一峰 CORS: <a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<blockquote>
<p><code>CORS</code>是基于<code>http1.1</code>的一种跨域解决方案，它的全称是<strong>C</strong>ross-<strong>O</strong>rigin <strong>R</strong>esource <strong>S</strong>haring，<strong>跨域资源共享</strong>。</p>
<p>CORS 需要浏览器和后端同时支持。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
</blockquote>
<p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<p>凡是不同时满足下面两个条件，就属于非简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP 的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<h5 id="跨域解决方法-3-jsonp">跨域解决方法 3-JSONP</h5>
<blockquote>
<p>JSONP 的做法是：当需要跨域请求时，不使用 AJAX，转而生成一个 script 元素去请求服务器，由于浏览器并不阻止 script 元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段 JS 代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</p>
<p>JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。</strong></p>
</blockquote>
<h4 id="11cookie">11、cookie</h4>
<p>什么是 cookie</p>
<blockquote>
<p>cookie 是储存在用户本地终端上的数据，是网站为了<strong>识别用户</strong>和<strong>跟踪会话</strong>而存储在用户本地终端中的文本数据</p>
</blockquote>
<p>怎么操作</p>
<blockquote>
<p>可以使用<code>js-cookie</code>插件</p>
<p>模块化开发时直接引入<code>import Cookies from 'js-cookie'</code></p>
<p>js-cookie.js 常用的 API 和方法</p>
<p>设置 cookie</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">Cookies</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="s2">&#34;value&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expires</span><span class="o">:</span> <span class="mi">7</span><span class="p">,</span> <span class="nx">path</span><span class="o">:</span> <span class="s2">&#34;&#34;</span> <span class="p">});</span> <span class="c1">//7天过期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Cookies</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s2">&#34;bar&#34;</span> <span class="p">});</span> <span class="c1">//设置一个json
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>读取 cookie</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">Cookies</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">);</span> <span class="c1">//获取cookie
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Cookies</span><span class="p">.</span><span class="nx">get</span><span class="p">();</span> <span class="c1">//读取所有的cookie
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>删除 cookie</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">Cookies</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">);</span> <span class="c1">//删除cookie时必须是同一个路径。
</span></span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<h4 id="12keep-alive-原理httpsblog-1gxfs2h1401f4f58-1254415986tcloudbaseappcome99da2e8af95e9a298e7b3bbe58897e4ba8ce38081e5afb9keep-alivee79a84e79086e8a7a3htmle58e9fe79086">12、<a href="https://blog-1gxfs2h1401f4f58-1254415986.tcloudbaseapp.com/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97/%E4%BA%8C%E3%80%81%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3.html#%E5%8E%9F%E7%90%86">keep-alive 原理</a></h4>
<h5 id="keep-alive-是什么">keep-alive 是什么</h5>
<blockquote>
<ol>
<li>vue 自带的组件 &raquo; 主要功能是缓存组件 &raquo; 提升性能</li>
<li>使用场景：可以少网络请求，如果当前组件数据量比较大，就可以节省网络请求 &raquo; 提升用户体验</li>
<li>举例：如果详情页面之间进行切换，就可以使用<code>keep-alive</code>进行缓存组件，防止同样的数据重复请求</li>
</ol>
</blockquote>
<p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>
<p><code>keep-alive</code>可以设置以下<code>props</code>属性：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例</li>
</ul>
<p>关于<code>keep-alive</code>的基本用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nx">keep</span><span class="o">-</span><span class="nx">alive</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nx">component</span> <span class="p">:</span><span class="nx">is</span><span class="p">=</span><span class="s">&#34;view&#34;</span><span class="p">&gt;&lt;</span><span class="o">/</span><span class="nx">component</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="o">/</span><span class="nx">keep</span><span class="o">-</span><span class="nx">alive</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)，匿名组件不能被匹配</p>
<p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（<code>activated</code>与<code>deactivated</code>）：</p>
<ul>
<li>首次进入组件时：<code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code>&gt; <code>mounted</code> &gt; <code>activated</code> &gt; &hellip; &hellip; &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li>
<li>再次进入组件时：<code>beforeRouteEnter</code> &gt;<code>activated</code> &gt; &hellip; &hellip; &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li>
</ul>
<h5 id="使用场景"><strong>使用场景</strong></h5>
<p>使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用<code>keep-alive</code></p>
<p>举个栗子:</p>
<p>当我们从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>再返回</code>，这时候列表页应该是需要<code>keep-alive</code></p>
<p>从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>返回到列表页(需要缓存)</code>–&gt;<code>返回到首页(需要缓存)</code>–&gt;<code>再次进入列表页(不需要缓存)</code>，这时候可以按需来控制页面的<code>keep-alive</code></p>
<p>在路由中设置<code>keepAlive</code>属性判断是否需要缓存</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;itemList&#39;</span><span class="p">,</span> <span class="c1">// 列表页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">component</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">require</span><span class="p">([</span><span class="s1">&#39;@/pages/item/list&#39;</span><span class="p">],</span> <span class="nx">resolve</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">},</span>
</span></span><span class="line"><span class="cl"> <span class="nx">meta</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">keepAlive</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;列表页&#39;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>&lt;keep-alive&gt;</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;app&#34;</span> <span class="kr">class</span><span class="o">=</span><span class="s1">&#39;wrapper&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">keep</span><span class="o">-</span><span class="nx">alive</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="c">&lt;!--</span> <span class="nx">需要缓存的视图组件</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="nx">router</span><span class="o">-</span><span class="nx">view</span> <span class="nx">v</span><span class="o">-</span><span class="k">if</span><span class="o">=</span><span class="s2">&#34;$route.meta.keepAlive&#34;</span><span class="o">&gt;&lt;</span><span class="err">/router-view&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="o">&lt;</span><span class="err">/keep-alive&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="c">&lt;!--</span> <span class="nx">不需要缓存的视图组件</span> <span class="o">--&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="o">&lt;</span><span class="nx">router</span><span class="o">-</span><span class="nx">view</span> <span class="nx">v</span><span class="o">-</span><span class="k">if</span><span class="o">=</span><span class="s2">&#34;!$route.meta.keepAlive&#34;</span><span class="o">&gt;&lt;</span><span class="err">/router-view&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="缓存后如何获取数据">缓存后如何获取数据</h5>
<p>解决方案可以有以下两种：</p>
<ul>
<li>beforeRouteEnter</li>
<li>actived</li>
</ul>
<h4 id="13ref">13、ref</h4>
<p>作用：</p>
<ul>
<li>放到 dom 节点上 &raquo; 获取原生 dom</li>
<li>组件身上 &raquo; 获取组件实例 &raquo; 可以获取组件内部所有的方法和数据</li>
</ul>
<h4 id="14scoped-原理是什么">14、scoped 原理是什么？</h4>
<p>作用：使<strong>样式私有化（模块化）</strong>，不对全局造成污染</p>
<p>原理：动态的给组件加上一个 hash 值，用属性选择器去匹配</p>
<h4 id="15router-和-route">15、$router 和 $route</h4>
<p><strong>$route</strong>：当前的路由信息对象，获取到路由参数、路径</p>
<blockquote>
<ol>
<li><strong>$route.path：</strong> 字符串，对应当前路由的路径，总是解析为绝对路径，如<code>/foo/bar</code>。</li>
<li><strong>$route.params：</strong> 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。</li>
<li><strong>$route.query：</strong> 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有$route.query.user == 1，如果没有查询参数，则是个空对象。</li>
<li><strong>$route.hash：</strong> 当前路由的 hash 值 (不带#) ，如果没有 hash 值，则为空字符串。锚点</li>
<li><strong>$route.fullPath：</strong> 完成解析后的 URL，包含查询参数和 hash 的完整路径。</li>
<li><strong>$route.matched：</strong> 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</li>
<li><strong>$route.name：</strong> 当前路径名字</li>
<li><strong>$route.meta：</strong> 路由元信息</li>
</ol>
</blockquote>
<p><strong>$router</strong>：全局路由 vueRouter 的实例，挂载到 Vue 原型上$router 属性，可以获取到全局路由配置信息，跳转方法</p>
<blockquote>
<p>$router.replace({path:&lsquo;home&rsquo;})，//替换路由，没有历史记录</p>
<p>$router.push(&rsquo;/login&rsquo;) ,跳转到指定路由</p>
<p>$router.back()</p>
<p>$router.go()</p>
</blockquote>
<h4 id="16发布订阅模式和观察者模式httpsjuejincnpost7055441354054172709heading-3">16、<a href="https://juejin.cn/post/7055441354054172709#heading-3">发布订阅模式和观察者模式</a></h4>
<h5 id="发布订阅模式">发布订阅模式</h5>
<blockquote>
<p>发布订阅模式中有三个角色，发布者 <code>Publisher</code> ，信息中心 <code>Event Channel</code> ，订阅者 <code>Subscriber</code></p>
<p>我们假定，存在一个&quot;信号中心&quot;，某个任务执行完成，就向信号中心&quot;发布&quot;（publish）一个信号，其他任务可以向信号中心&quot;订阅&quot;（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做&quot;发布/订阅模式&quot;（publish-subscribe pattern)</p>
<p><strong>通常是通过 on 事件订阅消息，emit 事件发布消息，remove 事件删除订阅</strong></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">PubSub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 事件中心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 存储格式: warTask: [], routeTask: []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 每种事件(任务)下存放其订阅者的回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 订阅方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">subscribe</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 发布方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">publish</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">cb</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">cb</span><span class="p">(...</span><span class="nx">args</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 取消订阅方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">unsubscribe</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">cbIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">e</span> <span class="o">===</span> <span class="nx">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">cbIndex</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">].</span><span class="nx">splice</span><span class="p">(</span><span class="nx">cbIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">].</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">unsubscribeAll</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="观察者模式">观察者模式</h5>
<p>当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是<strong>观察者模式</strong></p>
<blockquote>
<ul>
<li>观察者(订阅者) &ndash; Watcher
<ul>
<li>update()：当事件发生时，具体要做的事情</li>
</ul>
</li>
<li>目标(发布者) &ndash;  Dep
<ul>
<li>subs 数组：存储所有的观察者</li>
<li>addSub()：添加观察者</li>
<li>notify()：当事件发生，调用所有观察者的 update() 方法</li>
</ul>
</li>
<li>没有事件中心</li>
</ul>
</blockquote>
<h5 id="总结">总结</h5>
<table>
<thead>
<tr>
<th>设计模式</th>
<th>观察者模式</th>
<th>发布订阅模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>主体</td>
<td>Watcher 观察者、Dep 目标对象</td>
<td>Publisher 发布者、Event Channel 信息中心、Subscribe 订阅者</td>
</tr>
<tr>
<td>主体关系<br></td>
<td>Dep 中通过 subs 记录 Watcher</td>
<td>Publisher 和 Subscribe 不想不知道对方，通过中介联系</td>
</tr>
<tr>
<td>优点</td>
<td>角色明确，Watcher 和 Dep 要遵循约定的成员方法</td>
<td>松散耦合，灵活度高，通常应用在异步编程中</td>
</tr>
<tr>
<td>缺点</td>
<td>紧耦合</td>
<td>当事件类型变多时，会增加维护成本</td>
</tr>
<tr>
<td><strong>使用案例</strong></td>
<td>双向数据绑定</td>
<td>事件总线 EventBus</td>
</tr>
</tbody>
</table>
<h4 id="17vue-响应式原理数据劫持httpsblog-1gxfs2h1401f4f58-1254415986tcloudbaseappcomvuee58e9fe79086vue2e58e9fe790861e5938de5ba94e5bc8fe58e9fe79086html">17、<a href="https://blog-1gxfs2h1401f4f58-1254415986.tcloudbaseapp.com/vue%E5%8E%9F%E7%90%86/vue2%E5%8E%9F%E7%90%86/1.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html">vue 响应式原理（数据劫持）</a></h4>
<h4 id="18eventbus">18、eventBus</h4>
<h4 id="19v-model-与sync">19、v-model 与.sync</h4>
<blockquote>
<p><strong>相同点</strong>：都是语法糖，都可以实现父子组件中的数据的双向通信。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">//  v-model
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;</span><span class="nx">son</span>  <span class="nx">v</span><span class="o">-</span><span class="nx">model</span><span class="o">=</span><span class="s2">&#34;num&#34;</span><span class="o">/&gt;</span> <span class="c1">//父组件使用子组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">model</span><span class="o">:</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">prop</span><span class="o">:</span><span class="s1">&#39;newValue&#39;</span><span class="p">,</span> <span class="c1">// 默认为 value 可以使用prop自定义属性名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">event</span><span class="o">:</span><span class="s2">&#34;updateValue&#34;</span><span class="p">,</span> <span class="c1">// event 修改事件名 默认为input
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="nx">props</span><span class="o">:</span> <span class="p">{</span> <span class="c1">// 子组件接收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">value</span><span class="o">:</span> <span class="p">{</span>  <span class="c1">// 默认为value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">type</span><span class="o">:</span> <span class="nb">Number</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;小红&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// .sync
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;</span><span class="nx">son</span> <span class="o">:</span><span class="nx">title</span><span class="p">.</span><span class="nx">sync</span><span class="o">=</span><span class="s2">&#34;doc.title&#34;</span><span class="o">&gt;&lt;</span><span class="sr">/son&gt;   /</span><span class="o">/</span> <span class="nx">父组件</span>
</span></span><span class="line"><span class="cl"><span class="nx">props</span><span class="o">:</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">title</span><span class="o">:</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nx">type</span><span class="o">:</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;update:title&#39;</span><span class="p">,</span> <span class="nx">newTitle</span><span class="p">)</span>  <span class="c1">// 子组件
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>区别点</strong>：格式不同： v-model=&ldquo;num&rdquo;, :num.sync=&ldquo;num&rdquo;</p>
<p><code>v-model</code>：    @input + value
<code>:num.sync</code>:  @update:num</p>
<p><strong>另外需要特别注意的是:</strong> <code>v-model</code>只能用一次；<code>.sync</code>可以有多个</p>
</blockquote>
<h4 id="20如何做样式穿透">20、如何做样式穿透</h4>
<p><strong>背景</strong>：修改当前组件嵌套的子组件内部的样式</p>
<p><strong>问题</strong>：</p>
<ol>
<li>如果不添加 scoped，可能影响全局样式</li>
<li>如果添加 scoped，嵌套的子组件内部样式不能生效</li>
</ol>
<p><strong>如何解决</strong>：添加<code>/deep/</code> / <code>::v-deep</code></p>
<blockquote>
<p>scss: 使用<code>::v-deep</code></p>
<p>less: 使用 <code>/deep/</code></p>
</blockquote>
<h4 id="21你对spa单页面的理解它的优缺点分别是什么">21、你对SPA单页面的理解，它的优缺点分别是什么？</h4>
<blockquote>
<p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
</blockquote>
<h6 id="单页应用优缺点">单页应用优缺点</h6>
<p>优点：</p>
<ul>
<li>具有桌面应用的即时性、网站的可移植性和可访问性</li>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，SPA 相对对服务器压力小；</li>
<li>良好的前后端分离，分工更明确</li>
</ul>
<p>缺点：</p>
<ul>
<li>SEO（搜索引擎）难度较大</li>
<li>首次渲染速度相对较慢</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
</ul>
<h4 id="22怎么理解-vue-的单向数据流">22、怎么理解 Vue 的单向数据流</h4>
<blockquote>
<p>① 单向数据流是指数据从父组件传向子组件，子组件没有权限直接修改该数据；
② 子组件需要在 data 或者 computed 中重新定义变量来接收父组件传来的值，以便修改；
③ 子组件可以通过 $emit 的方式通知父组件修改值，再重新传回给子组件；</p>
</blockquote>
<h4 id="23路由懒加载">23、路由懒加载</h4>
<h6 id="为什么要使用路由懒加载">为什么要使用路由懒加载</h6>
<blockquote>
<p>为给客户更好的客户体验，首屏组件加载速度更快一些，解决白屏问题</p>
</blockquote>
<h6 id="定义">定义</h6>
<blockquote>
<p>懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载</p>
</blockquote>
<blockquote>
<p>路由 和 组件 的常用两种懒加载方式：</p>
<p>1、vue异步组件实现路由懒加载 <code>component：resolve=&gt;(['需要加载的路由的地址'，resolve])</code></p>
<p>2、es提出的import(推荐使用这种方式) <code>const HelloWorld = （）=&gt; import('需要加载的模块地址')</code></p>
</blockquote>
<p>通过魔法注释webpackChunkName修改名称，打包时就会显示修改后的新名称</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span> <span class="nx">name</span> <span class="p">}</span> <span class="o">=</span> <span class="kr">await</span> <span class="kr">import</span><span class="p">(</span><span class="cm">/* webpackChunkName:&#34;newName&#34;*/</span><span class="s1">&#39;路径&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="24如何理解vue的key属性">24、如何理解vue的key属性</h4>
<p><img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/GMFRTZ1Ew2igUmP.png?x-oss-process=style/huyu" alt="image-20220811205624543"></p>
<blockquote>
<pre><code> 	   **key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速，以便高效的更新虚拟 DOM**

 	   1.  对⽐规则：

 	       1. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
 	           1. 若虚拟DOM中内容没变, 直接使⽤之前的真实DOM
 	           2. 若虚拟DOM中内容变了, 则⽣成新的真实DOM，随后替换掉⻚⾯中之前的真
 	                实DOM

 	       2. 旧虚拟DOM中未找到与新虚拟DOM相同的key：创建新的真实DOM，随后渲染到
 	           到⻚⾯

 	         2. ⽤index作为key可能会引发的问题：
 	          1. 若对数据进⾏逆序添加、逆序删除等破坏顺序操作：会产⽣没有必要的真实DOM
 	              更新 ==&gt; 界⾯效果没问题, 但效率低
 	          2. 若结构中还包含输⼊类的DOM：会产⽣错误DOM更新 ==&gt; 界⾯有问题
 	         3. 开发中如何选择key?
 	          1. 最好使⽤每条数据的唯⼀标识作为key，⽐如id、⼿机号、⾝份证号、学号等唯⼀
 	              值
 	          2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅⽤于渲染列表，
 	              使⽤index作为key是没有问题的
</code></pre>
</blockquote>
<h4 id="25vue-router-有哪几种导航钩子">25、vue-router 有哪几种导航钩子</h4>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/meta.html">https://router.vuejs.org/zh/guide/advanced/meta.html</a></p>
<p><strong>全局导航钩子</strong></p>
<ul>
<li><code>router.beforeEach(to,from,next)</code>：添加一个导航守卫，在任何<strong>导航前</strong>执行</li>
<li><code>router.beforeResolve(to,from)</code>：添加一个导航守卫，在<strong>导航即将解析之前</strong>执行。在这个状态下，所有的组件都已经被获取，并且其他导航守卫也已经成功</li>
<li><code>router.afterEach(to,from)</code>：添加一个导航钩子，<strong>在每次导航后执行</strong></li>
</ul>
<p><strong>组件内的钩子</strong></p>
<ul>
<li><code>beforeRouterEnter(to, from, next)</code>：在渲染该组件的对应路由被验证前调用</li>
<li><code>beforeRouterUpdate</code>：在当前路由改变，但是该组件被复用时调用</li>
<li><code>beforeRouterLeave</code>：在导航离开渲染该组件的对应路由时调用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">UserDetails</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">template</span><span class="o">:</span> <span class="sb">`...`</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">beforeRouteEnter</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在渲染该组件的对应路由被验证前调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 不能获取组件实例 `this` ！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为当守卫执行时，组件实例还没被创建！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">beforeRouteUpdate</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在当前路由改变，但是该组件被复用时调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">beforeRouteLeave</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在导航离开渲染该组件的对应路由时调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>路由独享的守卫</strong></p>
<ul>
<li><code>beforeEnter</code>:<strong>只在进入路由时触发</strong>，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触发</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/users/:id&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">component</span><span class="o">:</span> <span class="nx">UserDetails</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">beforeEnter</span><span class="o">:</span> <span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// reject the navigation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/crRNltVTHoA8nXW.png?x-oss-process=style/huyu" alt="image-20220809005712651"></p>
<h4 id="26什么是-mvvm深入待总结">26、什么是 MVVM？（深入待总结）</h4>
<p><img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/4BpRdQsYCcEuwe6.webp?x-oss-process=style/huyu" alt="img"></p>
<blockquote>
<ul>
<li>Model：模型层（数据层），主要用于保存一些数据</li>
<li>View： 视图层，主要用于将后端数据借助各种元素呈现给用户，同时也可提供用户操作的入口</li>
<li>ViewModel：视图模型层：该层也是mvvm中的核心层，主要用于作为Model个View两个层的数据连接层，负责两个层之间的数据传递。该层主要包含两大功能点：
<ul>
<li>DOM监听（DOM Listener）视图变化后更新数据</li>
<li>数据绑定（Data bindings）数据变化后更新视图</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="27vue-是如何实现数据双向绑定的">27、Vue 是如何实现数据双向绑定的？</h4>
<p><a href="https://juejin.cn/post/6950939562872930341">https://juejin.cn/post/6950939562872930341</a></p>
<blockquote>
<p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p>
</blockquote>
<p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<ol>
<li>需要Observe（观察者）的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>Compile（编译）解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notify()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ol>
<p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章<a href="https://juejin.cn/post/6844903903822086151">《0 到 1 掌握：Vue 核心之数据双向绑定》</a>，有进行详细的讲解、以及代码 demo 示例</p>
<p><img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/ZykbSiv6VjH3Udl.webp?x-oss-process=style/huyu" alt="1158910-20180306234148823-430002059.png"></p>
<h4 id="28vueobservable你有了解过吗说说看">28、Vue.observable你有了解过吗？说说看</h4>
<p><a href="https://cowtransfer.com/s/1ef3d485042d4e">https://cowtransfer.com/s/1ef3d485042d4e</a> 点击链接查看 [ my2.jpg ] ，或访问奶牛快传 cowtransfer.com 输入传输口令 uk9ct9 查看；</p>
<h4 id="29v-model-的原理">29、v-model 的原理？</h4>
<p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input 表单元素为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">input</span> <span class="nx">v</span><span class="o">-</span><span class="nx">model</span><span class="o">=</span><span class="s1">&#39;something&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 相当于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;</span><span class="nx">input</span> <span class="nx">v</span><span class="o">-</span><span class="nx">bind</span><span class="o">:</span><span class="nx">value</span><span class="o">=</span><span class="s2">&#34;something&#34;</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">:</span><span class="nx">input</span><span class="o">=</span><span class="s2">&#34;something = $event.target.value&#34;</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="30data是个函数不是个对象">30、data是个函数不是个对象</h4>
<blockquote>
<p>首先，data是个函数是确保数据不会被污染，在JS中对象是一个引用数据类型，如果是对象形式，多个vue实例会相互影响，为了保证组件的复用性，data要写成函数，函数形式每次使用时，会返回一个新的对象拷贝，这样使用组件时data中的数据就不会被相互影响</p>
<p>new Vue的实例，比如app.js中，是不会被复用的，所以不存在数据污染的情况</p>
</blockquote>
<h4 id="31路由三种模式">31、路由三种模式</h4>
<p><strong>hash模式</strong></p>
<p><strong>history模式</strong></p>
<p><strong>abstract模式</strong></p>
<h4 id="32hash模式和history模式补充">32、hash模式和history模式（补充）</h4>
<p><a href="https://juejin.cn/post/6867875626611654663">https://juejin.cn/post/6867875626611654663</a></p>
<h6 id="前端路由原理">前端路由原理</h6>
<p>前端路由的核心，就在于改变视图的同时不会向后端发出请求；而是加载路由对应的组件。vue-router就是将组件映射到路由, 然后渲染出来的。并实现了三种模式：Hash模式、History模式以及Abstract模式。默认Hash模式</p>
<p><strong>hash模式</strong> ： #后面是路由路径，特点是前端访问，#后面的变化不会经过服务器</p>
<p><strong>history模式</strong>：正常的/访问模式，特点是后端访问，任意地址的变化都会访问服务器</p>
<h6 id="hash模式">Hash模式</h6>
<ul>
<li>原理
基于浏览器的<strong>hashchange事件</strong>，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。</li>
<li>优点</li>
</ul>
<ol>
<li>hash值会出现在URL中, 但是不会被包含在Http请求中, 因此hash值改变不会重新加载页面</li>
<li>hash改变会触发hashchange事件, 能控制浏览器的前进后退</li>
<li>兼容性好</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li><strong>地址栏中携带#，不美观</strong></li>
<li>只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL</li>
<li>hash有体积限制，故只可添加短字符串</li>
<li>设置的新值必须与原来不一样才会触发hashchange事件，并将记录添加到栈中</li>
<li><strong>每次URL的改变不属于一次http请求，所以不利于SEO优化</strong></li>
</ol>
<h6 id="history模式">History模式</h6>
<ul>
<li>原理
基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。</li>
<li>优点</li>
</ul>
<ol>
<li><strong>没有#，更加美观</strong></li>
<li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL</li>
<li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中</li>
<li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中</li>
<li>pushState() 可额外设置 title 属性供后续使用</li>
<li>浏览器的进后退能触发浏览器的popstate事件，获取window.location.pathname来控制页面的变化</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>URL的改变属于http请求，借助history.pushState实现页面的无刷新跳转，因此<strong>会重新请求服务器</strong>。所以前端的 URL 必须和实际向后端发起请求的 URL 一致。如果用户输入的URL回车或者浏览器刷新或者分享出去某个页面路径，用户点击后，URL与后端配置的页面请求URL不一致，则匹配不到任何静态资源，就会返回404页面。所以需要后台配置支持，覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应该返回app 依赖的页面或者应用首页。</li>
<li>兼容性差，特定浏览器支持</li>
</ol>
<h6 id="abstract模式">Abstract模式</h6>
<p>工作时没用过，支持所有javascript运行模式。vue-router 自身会对环境做校验，如果发现没有浏览器的 API，路由会自动强制进入 abstract 模式。在移动端原生环境中也是使用 abstract 模式。</p>
<h6 id="总结-1">总结</h6>
<p>hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。</p>
<h4 id="33说说你对slot的理解slot使用场景有哪些">33、说说你对slot的理解？slot使用场景有哪些？</h4>
<p><a href="https://vue3js.cn/interview/vue/slot.html#%E4%B8%80%E3%80%81slot%E6%98%AF%E4%BB%80%E4%B9%88">https://vue3js.cn/interview/vue/slot.html#%E4%B8%80%E3%80%81slot%E6%98%AF%E4%BB%80%E4%B9%88</a></p>
<h6 id="什么是slot"><strong>什么是slot</strong></h6>
<blockquote>
<p>slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定</p>
</blockquote>
<h6 id="slot的作用">slot的作用</h6>
<blockquote>
<p><strong>通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理</strong></p>
<p>如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情</p>
<p>通过<code>slot</code>插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用</p>
<p><strong>比如布局组件、表格列、下拉选、弹框显示内容等</strong></p>
</blockquote>
<h6 id="slot的分类">slot的分类</h6>
<blockquote>
<ul>
<li>
<p>默认插槽</p>
<ul>
<li>
<p>子组件用<code>&lt;slot&gt;</code>标签来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件使用的时候没有往插槽传入内容，标签内<code>DOM</code>结构就会显示在页面</p>
<p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p>
</li>
</ul>
</li>
<li>
<p>具名插槽</p>
<ul>
<li>
<p>子组件用<code>name</code>属性来表示插槽的名字，不传为默认插槽</p>
<p>父组件中在使用时在默认插槽的基础上加上<code>slot</code>属性，值为子组件插槽<code>name</code>属性值</p>
</li>
</ul>
</li>
<li>
<p>作用域插槽</p>
<ul>
<li>
<p>子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件<code>v-slot</code>接受的对象上</p>
<p>父组件中在使用时通过<code>v-slot:</code>（简写：#）获取子组件的信息，在内容中使用</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="34使用过-vue-ssr-吗说说-ssr">34、使用过 Vue SSR 吗？说说 SSR？</h4>
<p>服务器端渲染</p>
<h4 id="35说说你对vue的mixin的理解有什么应用场景">35、说说你对vue的mixin的理解，有什么应用场景？</h4>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">huyu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2022-02-11
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/vue/">vue</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/22.%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">高性能渲染十万条数据</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/13.js%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">
            <span class="next-text nav-default">js知识点总结</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/pan52yu" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>huyu</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








<script>
	function createCopyButton(highlightDiv) {
		const div = document.createElement("div");
		div.className = "copy-code";
		div.innerText = "Copy";
		div.addEventListener("click", () =>
			copyCodeToClipboard(div, highlightDiv)
		);
		addCopyButtonToDom(div, highlightDiv);
	}

	async function copyCodeToClipboard(button, highlightDiv) {
		const codeToCopy = highlightDiv.querySelector(":last-child > .chroma > code")
			.innerText;
		await navigator.clipboard.writeText(codeToCopy);
		button.blur();
		button.innerText = "Copied!";
		setTimeout(() => button.innerText = "Copy", 2000);
	}

	function addCopyButtonToDom(button, highlightDiv) {
		highlightDiv.insertBefore(button, highlightDiv.firstChild);
		const wrapper = document.createElement("div");
		wrapper.className = "highlight-wrapper";
		highlightDiv.parentNode.insertBefore(wrapper, highlightDiv);
		wrapper.appendChild(highlightDiv);
	}

	var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
	if(!isMobile){
		document.querySelectorAll(".highlight").forEach((highlightDiv) => createCopyButton(highlightDiv));
	}
</script>


</body>
</html>
