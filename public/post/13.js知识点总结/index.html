<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>js知识点总结 - Huyu&#39; Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="huyu" /><meta name="description" content="1、手动实现防抖和节流 防抖：事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时,，防止在短时间内过于频繁的执行相同的任务。当" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.105.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/13.js%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.a7c3372b17782ac7f2fa8c3cd7f2508f64a1456f433e3f82db4be08802b35f05.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="js知识点总结" />
<meta property="og:description" content="1、手动实现防抖和节流 防抖：事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时,，防止在短时间内过于频繁的执行相同的任务。当" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/13.js%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-09T17:09:35+00:00" />
<meta property="article:modified_time" content="2022-02-09T17:09:35+00:00" />

<meta itemprop="name" content="js知识点总结">
<meta itemprop="description" content="1、手动实现防抖和节流 防抖：事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时,，防止在短时间内过于频繁的执行相同的任务。当"><meta itemprop="datePublished" content="2022-02-09T17:09:35+00:00" />
<meta itemprop="dateModified" content="2022-02-09T17:09:35+00:00" />
<meta itemprop="wordCount" content="11786">
<meta itemprop="keywords" content="js," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="js知识点总结"/>
<meta name="twitter:description" content="1、手动实现防抖和节流 防抖：事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时,，防止在短时间内过于频繁的执行相同的任务。当"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Huyu&#39; Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Huyu&#39; Blog</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">js知识点总结</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-09 </span>
        <div class="post-category">
            <a href="/categories/%E9%9D%A2%E8%AF%95/"> 面试 </a>
            </div>
          <span class="more-meta"> 约 11786 字 </span>
          <span class="more-meta"> 预计阅读 24 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h4 id="1手动实现防抖和节流">1、手动实现<code>防抖</code>和<code>节流</code></h4>
<blockquote>
<p><strong>防抖</strong>：事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时,，防止在短时间内过于频繁的执行相同的任务。当短时间内的频繁是不必要的时候，就可以考虑去抖动，避免资源浪费，或造成不友好的体验。</p>
<p><strong>节流</strong>：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效</p>
<p><strong>防抖函数的应用场景：</strong></p>
<ul>
<li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</li>
<li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</li>
</ul>
<p><strong>节流函数的适⽤场景：</strong></p>
<ul>
<li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</li>
<li>缩放场景：监控浏览器resize</li>
<li>动画场景：避免短时间内多次触发动画引起性能问题</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * debounce 防抖
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param fn [function] 需要防抖的函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param delay [number] 毫秒，防抖期限值
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">//借助闭包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 所以要取消当前的计时，重新开始计时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arg</span><span class="p">);</span> <span class="c1">// 使用apply将fn函数的this指向修改为return后的function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span> <span class="c1">// 进入该分支说明当前并没有在计时，那么就开始一个计时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * debounce 节流
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param fn [function] 需要节流的函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param delay [number] 毫秒
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">valid</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 节流阀
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">valid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//休息时间 暂不接客
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 工作时间，执行函数并且在间隔期内把状态位设为无效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">valid</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">valid</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2letconstvar-的区别">2、let、const、var 的区别</h4>
<blockquote>
<p><strong>1.是否存在变量提升？</strong></p>
<ul>
<li>
<p><code>var</code>声明的变量存在变量提升（将变量提升到当前<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope">作用域</a>的顶部）。即变量可以在声明之前调用，值为<code>undefined</code></p>
</li>
<li>
<p><code>let</code>和<code>const</code>不存在变量提升。即它们所声明的变量一定要在声明后使用，否则报<code>ReferenceError</code>错</p>
</li>
</ul>
<p><strong>2.是否存在暂时性死区？</strong></p>
<p><code>let和const存在暂时性死区</code>。即只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响</p>
<p><strong>3.是否允许重复声明变量？</strong></p>
<ul>
<li>
<p><code>var</code>允许重复声明变量。</p>
</li>
<li>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量。</p>
</li>
</ul>
<p><strong>4.是否存在块级作用域？</strong></p>
<ul>
<li>var 不存在块级作用域。</li>
<li>let 和 const 存在块级作用域
<ul>
<li>块作用域由<code>{ }</code>包括，<code>if</code>语句和<code>for</code>语句里面的<code>{ }</code>也属于块作用域</li>
</ul>
</li>
</ul>
<p><strong>5. 是否能修改声明的变量？</strong></p>
<ul>
<li><code>var</code>和<code>let</code>可以。</li>
<li><code>const</code>声明一个只读的<strong>常量</strong>。一旦声明，常量的值就不能改变。<code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
</ul>
</blockquote>
<h4 id="3箭头函数与普通函数区别">3、箭头函数与普通函数区别</h4>
<blockquote>
<p>1.箭头函数是匿名函数，不能作为构造函数，不能使用 new</p>
<p>2.箭头函数内没有<code>arguments</code>，可以用展开运算符<code>...</code>解决</p>
<p>3.箭头函数的 this，始终指向父级上下文（箭头函数的<code>this</code>取决于定义位置<code>父级的上下文</code>，跟使用位置没关系，普通函数<code>this</code>指向调用的那个对象）</p>
<p>4.箭头函数不能通过<code>call() 、 apply() 、bind()</code>方法直接修改它的 this 指向。(<code>call、apply、bind</code>会默认忽略第一个参数，但是可以正常传参)</p>
<p>5.箭头函数没有原型属性</p>
</blockquote>
<h4 id="4promise">4、Promise</h4>
<ul>
<li>
<p>状态</p>
<ul>
<li>
<p><strong>进行中</strong>：<code>pending</code></p>
</li>
<li>
<p><strong>已成功</strong>：<code>resolved</code></p>
</li>
<li>
<p><strong>已失败</strong>：<code>rejected</code></p>
</li>
</ul>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p>对象的状态不受外界影响</p>
</li>
<li>
<p>一旦状态改变就不会再变，任何时候都可得到这个结果</p>
</li>
</ul>
</li>
<li>
<p>声明：<code>new Promise((resolve, reject) =&gt; {})</code></p>
</li>
<li>
<p>出参</p>
<ul>
<li>
<p><strong>resolve</strong>：将状态从<code>未完成</code>变为<code>成功</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</p>
</li>
<li>
<p><strong>reject</strong>：将状态从<code>未完成</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</p>
</li>
</ul>
</li>
</ul>
<p><strong>① 什么是 Promise？</strong></p>
<ul>
<li>Promise，简单说就是一个<code>容器</code>，包含异步操作结果的对象</li>
<li>从语法上说，<strong>promise</strong> 是一个<code>对象</code>，从它可以获取异步操作的的最终状态（成功或失败）。</li>
<li>Promise 是一个<code>构造函数</code>，对外提供统一的 API，自己身上有 all、reject、resolve 等方法，原型上有 then、catch 等方法。</li>
</ul>
<p><strong>② Promise 有什么用？</strong></p>
<p>解决回调地狱</p>
<p>ps:什么是回调地狱？回调地狱，其实简单来说就是异步回调函数的嵌套</p>
<p><strong>③Promise 有哪些方法</strong></p>
<ul>
<li>
<p>**then()：**分别指定<code>resolved状态</code>和<code>rejected状态</code>的回调函数</p>
<ul>
<li>
<p><strong>第一参数</strong>：状态变为<code>resolved</code>时调用</p>
</li>
<li>
<p><strong>第二参数</strong>：状态变为<code>rejected</code>时调用(可选)</p>
</li>
<li>
<p><strong>链式调用 promise.then()</strong>：<strong><code>then</code> 方法返回一个 Promise 对象，其允许方法链，从而创建一个 promise 链</strong></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>catch()</strong>：指定发生错误时的回调函数</p>
</li>
<li>
<p><strong>Promise.resolve()</strong>：将对象转为 Promise 对象 等价于 <code>new Promise(resolve =&gt; resolve())</code></p>
<ul>
<li>
<p><strong>Promise 实例</strong>：原封不动地返回入参</p>
</li>
<li>
<p><strong>thenable 对象</strong>：</p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象</p>
<p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法</p>
</li>
<li>
<p><strong>不具有 then()的对象</strong>：将此对象转为 Promise 对象并返回，状态为<code>resolved</code></p>
</li>
<li>
<p><strong>不带参数</strong>：返回 Promise 对象，状态为<code>resolved</code></p>
</li>
</ul>
</li>
<li>
<p><strong>Promise.reject()</strong>：将对象转为状态为<code>rejected</code>的 Promise 对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</p>
</li>
<li>
<p><strong>Promise.all()：</strong></p>
<p>并发，<strong>发起多个并发请求</strong>，将多个实例包装成一个新实例（数组形式），然后在所有 promise 都被解决后执行一些操作(齐变更再返回)</p>
<ul>
<li>成功：只有全部实例状态变成<code>fulfilled</code>（ 成功 ），最终状态才会变成<code>fulfilled</code></li>
<li>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></li>
<li>每一个 promise 成功的值，会按照传入的顺序返回数组内</li>
<li>用 all 方法进行接口请求，就算其中有失败的情况，别的请求也会进行，但最后的状态还是<code>rejected</code></li>
</ul>
</li>
<li>
<p><strong>Promise.race()：</strong></p>
<p>赛跑机制</p>
<p>将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</p>
<ul>
<li>成功失败：哪个实例率先改变状态就返回哪个实例的状态</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Promise.finally()</strong>：指定不管最后状态如何都会执行的回调函数</li>
<li>**Promise.allSettled()**⭐：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)
<ul>
<li>成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</li>
<li>失败：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</li>
</ul>
</li>
<li><strong>Promise.any()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</li>
</ul>
<ul>
<li>
<p>成功：其中一个实例状态变成<code>fulfilled</code>，最终状态就会变成<code>fulfilled</code></p>
</li>
<li>
<p>失败：只有全部实例状态变成<code>rejected</code>，最终状态才会变成<code>rejected</code></p>
</li>
</ul>
<ul>
<li><strong>Promise.try()</strong>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li>
</ul>
<p><strong>常见的错误</strong></p>
<ul>
<li>
<p><code>Uncaught TypeError: undefined is not a promise</code></p>
<p>如果在控制台中收到 <code>Uncaught TypeError: undefined is not a promise</code> 错误，则请确保使用 <code>new Promise()</code> 而不是 <code>Promise()</code></p>
</li>
<li>
<p><strong><code>UnhandledPromiseRejectionWarning</code></strong></p>
<p>这意味着调用的 promise 被拒绝，但是没有用于处理错误的 catch。 在 then 之后添加 catch 则可以正确地处理</p>
</li>
</ul>
<blockquote>
<p>扩展：<a href="https://juejin.cn/post/7043758954496655397#heading-2">手写 Promise</a></p>
</blockquote>
<h4 id="5数据类型">5、数据类型</h4>
<p>原始数据类型（<strong>基本类型</strong>）：按值访问，可以操作保存在变量中实际的值。</p>
<ul>
<li><strong>空值</strong>（<code>null</code>）：用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li>
<li><strong>未定义</strong>（<code>undefined</code>）: 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li>
<li><strong>布尔值</strong>（<code>boolean</code>）：用于 <code>true</code> 和 <code>false</code>。</li>
<li><strong>数字</strong>（<code>number</code>）：用于任何类型的数字：整数或浮点数，在 <code>±(253-1)</code> 范围内的整数。</li>
<li><strong>字符串</strong>（<code>string</code>）：用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li>
<li><strong>符号</strong>（<code>symbol</code>）:用于唯一的标识符。</li>
<li>BigInt:一种数字类型,可以表示任意精度格式的整数</li>
</ul>
<p>引用类型（<strong>复杂数据类型</strong>）：引用类型的值是保存在内存中的对象。</p>
<ul>
<li>对象（<strong>Object</strong>）
<ul>
<li>数组对象（Array）</li>
<li>函数对象（Function）</li>
<li>布尔对象（Boolean）</li>
<li>数字对象（Number）</li>
<li>字符串对象（String）</li>
<li>日期对象（Date）</li>
<li>正则对象（RegExp）</li>
<li>错误对象（Error）</li>
</ul>
</li>
</ul>
<blockquote>
<p>⚠️ <strong>注意</strong>： 与其他语言不同的是，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。所以引用类型的值是按引用访问的。</p>
</blockquote>
<h4 id="6检测数据类型的常用方法">6、检测数据类型的常用方法</h4>
<blockquote>
<p><strong>typeof、instanceof、constructor、Object.prototype.toString.call()</strong></p>
</blockquote>
<h6 id="1-typeof">1 .typeof</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="k">typeof</span> <span class="mi">100</span><span class="p">,</span> <span class="c1">//&#34;number&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typeof</span> <span class="kc">undefined</span><span class="p">,</span> <span class="c1">//&#34;undefined&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typeof</span> <span class="kc">null</span><span class="p">,</span> <span class="c1">//&#34;object&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typeof</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;aaa&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="c1">//&#34;function&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typeof</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="c1">//&#39;object&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typeof</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&#34;abc&#34;</span><span class="p">),</span> <span class="c1">// &#39;string&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typeof</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">//&#39;boolean&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>typeof 可以正常检测出：number、boolean、string、object、function、undefined、symbol、bigint</p>
<ul>
<li>检测基本数据类型，null 会检测 object，因为 null 是一个空的引用对象</li>
<li>检测复杂数据类型，除 function 外，均为 object</li>
</ul>
</blockquote>
<h6 id="2--instanceof"><strong>2 . instanceof</strong></h6>
<p><code>instanceof</code> 运算符需要指定一个构造函数，或者说指定一个特定的类型，用来判断这个构造函数的原型是否在给定对象的原型链上</p>
<blockquote>
<p>基本数据类型中：Number，String，Boolean。字面量值不可以用 instanceof 检测，但是构造函数创建的值可以</p>
<p>注意：null 和 undefined 都返回了 false，这是因为它们的类型就是自己本身，并不是 Object 创建出来它们，所以返回了 false。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="mi">100</span> <span class="k">instanceof</span> <span class="nb">Number</span><span class="p">,</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kc">undefined</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">,</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">,</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">new</span> <span class="nb">Error</span><span class="p">()</span> <span class="k">instanceof</span> <span class="nb">Error</span> <span class="c1">//true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="3-constructor"><strong>3 .constructor</strong></h6>
<p>constructor 是 prototype 对象上的属性，指向构造函数。根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的。可以检测出字面量方式创建的对象类型</p>
<p>如果输出一个类型的实例的 constructor，就如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="nx">constructor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//ƒ Number() { [native code] }
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到它指向了 Number 的构造函数，因此，可以使用<code>num.constructor === Number</code>来判断一个变量是不是 Number 类型的</p>
<p>除了 undefined 和 null 之外，其他类型都可以通过 constructor 属性来判断类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&#34;abcdef&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">bool</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// undefined和null没有constructor属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">num</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Number</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">str</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">String</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bool</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">arr</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Array</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//所有结果均为true
</span></span></span></code></pre></td></tr></table>
</div>
</div><h6 id="4--使用-objectprototypetostringcall检测对象类型"><strong>4 . 使用 Object.prototype.toString.call()检测对象类型</strong>⭐</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">toString</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">//&#34;[object Number]&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">//&#34;[object Undefined]&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">//&#34;[object Null]&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="sr">/^[a-zA-Z]{5,20}$/</span><span class="p">);</span> <span class="c1">//&#34;[object RegExp]&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">());</span> <span class="c1">//&#34;[object Error]&#34;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以使用<code>Object.prototype.toString.call(obj).slice(8，-1)</code>来判断并截取</p>
<p>使用<code>Object.prototype.toString.call()</code>的方式来判断一个变量的类型是最准确的方法</p>
<h6 id="5--自己封装函数"><strong>5 . 自己封装函数</strong></h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getType</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">type</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">!==</span> <span class="s2">&#34;object&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//如果不是object类型的数据，直接用typeof就能判断出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//如果是object类型数据，准确判断类型必须使用Object.prototype.toString.call(obj)的方式才能判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^\[object (\S+)]$/</span><span class="p">,</span> <span class="s2">&#34;$1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="6isarray"><strong>6、isArray</strong></h6>
<p>isArray 可以检测出是否为数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="7数组的常用方法有哪些">7、数组的常用方法有哪些</h4>
<h5 id="一操作方法">一、操作方法</h5>
<h6 id="增">增</h6>
<p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>
<blockquote>
<p>push( ) unshift( ) splice( ) concat( )</p>
</blockquote>
<p><strong>push()</strong></p>
<p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p>
<p><strong>unshift()</strong></p>
<p>unshift()在数组开头添加任意多个值，然后返回新的数组长度</p>
<p><strong>splice</strong></p>
<p>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回的是空数组</p>
<p><strong>concat()</strong></p>
<p>合并</p>
<p>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p>
<p><code>let colors = [&quot;red&quot;].concat(&quot;yellow&quot;, [&quot;black&quot;]);// [&quot;red&quot;, &quot;yellow&quot;, &quot;black&quot;]</code></p>
<h6 id="删">删</h6>
<p>下面三种都会影响原数组，最后一项不影响原数组：</p>
<blockquote>
<p>pop() shift() splice() slice()</p>
</blockquote>
<p><strong>pop()</strong></p>
<p><code>pop()</code> 方法用于删除数组的最后一项，同时减少数组的<code>length</code> 值，返回被删除的项</p>
<p><strong>shift()</strong></p>
<p><code>shift()</code>方法用于删除数组的第一项，同时减少数组的<code>length</code> 值，返回被删除的项</p>
<p><strong>splice()</strong></p>
<p>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p>
<p><strong>slice()</strong></p>
<p>slice(开始索引, 结束索引) ，返回一个新数组，不会影响原始数组</p>
<h6 id="改">改</h6>
<p>即修改原来数组的内容，常用<code>splice</code></p>
<p><strong>splice()</strong></p>
<p>传入三个参数，分别是（开始位置，要删除元素的数量，要插入的任意多个元素)，返回删除元素的数组</p>
<p>会改变原数组</p>
<h6 id="查">查</h6>
<p>查找元素，返回元素坐标或者元素值</p>
<blockquote>
<p>indexOf( )  includes( )  find( )</p>
</blockquote>
<p><strong>indexOf()</strong></p>
<p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<p><strong>includes()</strong></p>
<p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>
<p><strong>find()</strong></p>
<p>返回第一个匹配的元素</p>
<h5 id="二排序方法">二、排序方法</h5>
<blockquote>
<p>reverse()sort()</p>
</blockquote>
<h6 id="reverse">reverse()</h6>
<p>翻转</p>
<h6 id="sort">sort()</h6>
<p>排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">sortArr</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span> <span class="c1">// 升序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// 降序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="三转换方法">三、转换方法</h5>
<h6 id="join">join()</h6>
<p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串，转为字符串</p>
<h5 id="四迭代方法">四、迭代方法</h5>
<p>常用来迭代数组的方法（除 forEach 外其他都不会对空数组进⾏检测、不会改变原始数组）有如下：</p>
<blockquote>
<p>some() every() forEach() filter() map()</p>
</blockquote>
<h6 id="some">some()</h6>
<p>对数组每一项都运行传入的测试函数，如果至少有 1 个元素返回 true ，则这个方法返回 true</p>
<h6 id="every">every()</h6>
<p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<h6 id="foreach">forEach()</h6>
<p>对数组每一项都运行传入的函数，没有返回值</p>
<h6 id="filter">filter()</h6>
<p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>
<h6 id="map">map()</h6>
<p>映射 对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<h4 id="8深浅拷贝">8、深浅拷贝</h4>
<blockquote>
<p><strong>基本类型</strong>数据保存在在<strong>栈</strong>内存中</p>
<p><strong>引用类型</strong>数据保存在<strong>堆</strong>内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p>
</blockquote>
<p><img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/eq4kTpIjEyhCWwu.png?x-oss-process=style/huyu" alt=""></p>
<h5 id="深拷贝和浅拷贝的区别">深拷贝和浅拷贝的区别</h5>
<p><strong>1.浅拷贝</strong>： 将原对象或原数组的引用直接赋给新对象，新数组，新对象/数组只是原对象的一个引用。</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址，即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p>
<p><strong>2.深拷贝</strong>： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”</p>
<h5 id="浅拷贝">浅拷贝</h5>
<p><strong>数组浅拷贝:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 直接遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">shallowCopy</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">newArr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">newArr2</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    concat() 合并空数组实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">newArr3</span> <span class="o">=</span> <span class="nx">arr3</span><span class="p">.</span><span class="nx">concat</span><span class="p">([]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>对象浅拷贝:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// 直接遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">shallowCopy</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">newObj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newObj</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">item</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">newObj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用拓展运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Bob&#34;</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="mi">17</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">newObj2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">obj2</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="深拷贝">深拷贝</h5>
<blockquote>
<p>用深拷贝最后要递归到全部是基本值，不然可能会陷入死循环/循环引用，导致栈溢出</p>
<p>TODO(待理解)⭐： 处理过的数据使用 map 结构缓存起来 &raquo; 递归的时候碰到相同的数据 &raquo; 直接使用缓存里面的</p>
</blockquote>
<p><strong>1. 先转换成字符串，在转换成(数组/对象) JSON.parse(JSON.stringify(XXXX))</strong></p>
<p>有一个缺点 里面的函数不能拷贝</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">number</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">number</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">number</span><span class="o">:</span> <span class="mi">3</span> <span class="p">}];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">copyArray</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>2、递归实现简单的深拷贝：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">obj</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span> <span class="o">!==</span> <span class="s2">&#34;object&#34;</span> <span class="o">||</span> <span class="nx">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// obj 是 null ，或者不是对象和数组，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="o">?</span> <span class="p">(</span><span class="nx">result</span> <span class="o">=</span> <span class="p">[])</span> <span class="o">:</span> <span class="p">(</span><span class="nx">result</span> <span class="o">=</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 保证 key 不是原型的属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 递归调用！！！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>3、解构赋值法实现一层拷贝</strong></p>
<p><strong>4、Object.assign() 实现一层深拷贝</strong></p>
<p><strong>5、 lodash第三方库</strong></p>
<p><strong>小结</strong></p>
<p>前提为拷贝类型为引用类型的情况下：</p>
<ul>
<li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</li>
<li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li>
</ul>
<h4 id="9闭包">9、闭包</h4>
<p><strong>什么是闭包</strong></p>
<blockquote>
<p>通俗地讲闭包就是在一个函数里边再定义一个函数，这个内部函数一直保持有对外部函数中作用域的访问权限(小房间一直可以有大房子的访问权限)</p>
</blockquote>
<p><strong>闭包的作用</strong></p>
<blockquote>
<ol>
<li>访问其他函数内部变量</li>
<li>保护变量不被 JS 的垃圾回收机制回收</li>
<li>避免全局变量被污染 方便调用上下文的局部变量 加强封装性</li>
</ol>
</blockquote>
<p><strong>闭包的优点</strong></p>
<blockquote>
<p>（一）变量长期驻扎在内存中
（二）另一个就是可以重复使用变量，并且不会造成变量污染
① 全局变量可以重复使用，但是容易造成变量污染。不同的地方定义了相同的全局变量,这样就会产生混乱。
② 局部变量仅在局部作用域内有效，不可以重复使用，不会造成变量污染。
③ 闭包结合了全局变量和局部变量的优点。可以重复使用变量，并且不会造成变量污染</p>
</blockquote>
<p><strong>闭包的缺点</strong></p>
<blockquote>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
</blockquote>
<h4 id="10数组去重">10、数组去重</h4>
<p><a href="https://segmentfault.com/a/1190000016418021">https://segmentfault.com/a/1190000016418021</a></p>
<h6 id="set-去重">Set 去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">)];</span> <span class="c1">// [ 1, 2, 3, 4, 5 ]
</span></span></span></code></pre></td></tr></table>
</div>
</div><h6 id="indexof-去重">indexOf 去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">newArr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">newArr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="splice-去重">splice 去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="includes-去重">includes 去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">newArr</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">newArr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="filter-去重">filter 去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//当前元素，在原始数组中的第一个索引===当前索引值，否则返回当前元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">===</span> <span class="nx">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="findindex数组对象去重">findIndex数组对象去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// todo:待总结数组去重方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 方法一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">findIndex</span><span class="p">((</span><span class="nx">child</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="o">===</span> <span class="nx">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="map数组对象去重">Map数组对象去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="o">!</span><span class="nx">res</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="reduce-数组对象去重">reduce 数组对象去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">obj</span><span class="p">[</span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">?</span> <span class="s2">&#34;&#34;</span> <span class="o">:</span> <span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span> <span class="p">[]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="lodash-库数组和数组对象去重">lodash 库数组和数组对象去重</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">isEqual</span><span class="p">,</span> <span class="nx">uniqWith</span><span class="p">,</span> <span class="nx">uniqBy</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;lodash&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;sli&#34;</span><span class="p">,</span> <span class="nx">year</span><span class="o">:</span> <span class="mi">2012</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;ap&#34;</span><span class="p">,</span> <span class="nx">year</span><span class="o">:</span> <span class="mi">2015</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;alslion&#34;</span><span class="p">,</span> <span class="nx">year</span><span class="o">:</span> <span class="mi">2012</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;pose&#34;</span><span class="p">,</span> <span class="nx">year</span><span class="o">:</span> <span class="mi">2012</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;pose&#34;</span><span class="p">,</span> <span class="nx">year</span><span class="o">:</span> <span class="mi">2012</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 根据id去掉相同的元素:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uniqBy</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="s2">&#34;id&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 深检查数组每一项进行去重:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uniqWith</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">isEqual</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="11逻辑运算符--和-">11、逻辑运算符 &amp;&amp; 和 ||</h4>
<p><strong>||运算符: 条件 1 || 条件 2</strong></p>
<ul>
<li>若条件 1 为 true、返回条件 1</li>
<li>若条件 1 为 false、不管 || 后面是 true 还是 false、都是返回||后面的值、即则返回条件 2;</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span> <span class="o">||</span> <span class="s2">&#34;&#34;</span><span class="p">);</span> <span class="c1">// &#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;&#34;</span> <span class="o">||</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>&amp;&amp;运算符: 条件 1 &amp;&amp; 条件 2</strong></p>
<ul>
<li>若条件 1 为 false、就返回返回条件 1 的值;</li>
<li>若条件 1 为 true, 无论条件 2 为 true 或者 false, 都将返回条件 2 的值;</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s2">&#34;&#34;</span><span class="p">);</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// &#39;&#39;
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="12new-的过程">12、new 的过程</h4>
<p>分析一下 new 的整个过程：</p>
<ul>
<li>1、创建一个空对象</li>
<li>2、this 指向 obj 空对象，并调用构造函数</li>
<li>3、继承构造函数的原型</li>
<li>4、返回对象</li>
</ul>
<p>简单实现一下 new：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">myNew</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第一步：创建一个空对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第二步：this指向obj 空对象，并调用构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第三步：继承构造函数的原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第四步：返回对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="13事件循环-event-loop--结合着14条讲">13、事件循环 Event Loop  （结合着14条讲）</h4>
<p><strong>是什么？</strong></p>
<blockquote>
<p>首先，<code>JavaScript</code>是一门单线程的语言，意味着同一时间内只能做一件事，如果前面一个任务耗时太长，后续的任务不得不等待，可能会导致程序假死的问题，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p>
</blockquote>
<p>在<code>JavaScript</code>中，所有的任务都可以分为</p>
<ul>
<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>
<li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li>
</ul>
<p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。过程不断重复就是<strong>事件循环</strong></p>
<h4 id="14async-和-await-宏任务-和-微任务">14、async 和 await 宏任务 和 微任务</h4>
<p><a href="https://www.mianshiya.com/qd/bf4a0bf261c7e2500090d9482499675f">https://www.mianshiya.com/qd/bf4a0bf261c7e2500090d9482499675f</a></p>
<h5 id="宏任务-和-微任务">宏任务 和 微任务</h5>
<p>下面代码执行顺序是什么</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">// 同步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>  <span class="c1">// 宏任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)=&gt;{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;new Promise&#39;</span><span class="p">)</span> <span class="c1">// 同步
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resolve</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(()=&gt;{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;then&#39;</span><span class="p">)</span>  <span class="c1">// 微任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// 同步
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>1</code>=&gt;<code>'new Promise'</code>=&gt; <code>3</code> =&gt; <code>'then'</code> =&gt; <code>2</code></p>
<h6 id="1什么是宏任务和微任务">1、什么是宏任务和微任务</h6>
<p>Javascript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是：</p>
<p><strong>微任务：</strong></p>
<p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>
<p>常见的微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<p><strong>宏任务：</strong></p>
<p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>
<p>常见的宏任务有：</p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout/setInterval</li>
<li>UI rendering/UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I/O（Node.js）</li>
</ul>
<blockquote>
<p><strong>promise里面的代码是同步任务 promise的方法.then()等是异步任务 微任务</strong></p>
</blockquote>
<h6 id="2宏任务和微任务的执行顺序">2、宏任务和微任务的执行顺序</h6>
<img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/YvSB58sUMZg7l31.png?x-oss-process=style/huyu" >
<p>每一个宏任务执行完之后，都会检查是否存在待执行的微任务，如果有，则执行完所有微任务之后，再继续执行下一个宏任务。</p>
<blockquote>
<p><strong>1、微任务比宏任务的执行时间要早</strong></p>
<p><strong>2、微任务在DOM渲染之前执行，宏任务在DOM渲染之后执行</strong></p>
</blockquote>
<h5 id="async与await">async与await</h5>
<blockquote>
<p><code>async</code> 是异步的意思，<code>await</code>是等待。所以可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>
</blockquote>
<h6 id="async">async</h6>
<p><code>async</code>函数返回一个<code>promise</code>对象</p>
<h6 id="await">await</h6>
<p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>
<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码（加入微任务列表）</p>
<p>下面代码执行顺序是什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;async1 start&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">await</span> <span class="nx">async2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;async1 end&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">async2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;async2&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;script start&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;settimeout&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="nx">async1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise1&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resolve</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise2&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;script end&#39;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析过程：</p>
<ol>
<li>执行整段代码，遇到 <code>console.log('script start')</code> 直接打印结果，输出 <code>script start</code></li>
<li>遇到定时器了，它是宏任务，先放着不执行</li>
<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>
<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li>
<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li>
<li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li>
<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>
</ol>
<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>
<h4 id="15callapplybind-的区别">15、<strong>call、apply、bind 的区别</strong></h4>
<ul>
<li>都可以改变 <code>this</code> 指向</li>
<li>call 和 apply 会<code>立即执行</code>，bind 不会，而是返回一个函数</li>
<li>call 和 bind 可以接收<code>多个参数</code>，<code>apply</code> 只能接受两个，第二个是<code>数组</code></li>
<li>bind 参数可以分多次传入</li>
</ul>
<h4 id="16继承">16、继承</h4>
<blockquote>
<p><strong>首先，继承的是 属性 和 原型方法</strong></p>
</blockquote>
<h5 id="class-继承">Class 继承</h5>
<p>ES6：https://es6.ruanyifeng.com/#docs/class-extends</p>
<blockquote>
<p>Class 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法</p>
<p>子类如果写 <code>constructor()</code>就必须要写 <code>super()</code>,且要写在最前面，否则报错，只有<code>super()</code>方法才能让子类实例继承父类。</p>
<p>👊ps: ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">		<span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Son</span> <span class="kr">extends</span> <span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 调用父类的constructor(x, y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="kr">super</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// 调用父类的toString()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="es5-继承">ES5 继承</h5>
<blockquote>
<p>js 中有很多中继承的方式，不过每一种继承方式都有优缺点，重点掌握 ES5 继承，别的继承方式基本都是 ES5 继承的语法糖</p>
</blockquote>
<blockquote>
<p>先创造子类实例，通过<code>Parent.call(this, arg1, arg2...)</code>将父类的属性方法添加到<code>this</code>上，继承了父类的属性</p>
<p>再通过 <code>Son.prototype = Object.create( Father.prototype )</code>将父类的原型继承过来</p>
<p>最后可以通过<code>Son.prototype.constructor = Son</code> 将子类的原型指到子类身上</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Father</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s2">&#34;黑马&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 继承的是 属性 和 原型方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">Son</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Father</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Son.prototype = new Father() // 相互影响 会存在一个 {name:undefined}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Object.create 创造出一个空对象
</span></span></span><span class="line"><span class="cl"><span class="c1">// 让当前对象的__proto__ 指向传入的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Son</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">son</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">(</span><span class="s2">&#34;程序员&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">son</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span> <span class="o">+</span> <span class="nx">son</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 黑马程序员
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="17原型链">17、原型链</h4>
<p><strong>什么是原型原型链？</strong></p>
<blockquote>
<p>每个函数都有一个 prototype 原型(原型就是对象)，原型对象有一个 constructor 属性，指向的是构造函数</p>
<p>访问对象的某一个属性或者方法时，会从对象自身查找，如果查找不到，就会去原型链上去找，原型的最终目的就是让所有的实例能够共享其属性和方法</p>
<p>查找顺序:</p>
<p>自身 &gt;<code>__proto__</code>&gt; 构造函数的原型对象 &gt;<code>__proto__</code>&gt; Object 的原型对象 &gt;<code>__proto__</code>&gt; null</p>
</blockquote>
<p><img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/zlOJPgIK3y7YkWh.png?x-oss-process=style/huyu" alt=""></p>
<h4 id="18堆和栈-todo-">18、堆和栈 TODO ⭐⭐</h4>
<p><a href="https://juejin.cn/post/6844903618999500808">https://juejin.cn/post/6844903618999500808</a></p>
<h4 id="19es6-set-和-map-todo-">19、ES6 Set 和 Map TODO ⭐⭐</h4>
<h4 id="20includes">20、<strong>includes</strong></h4>
<blockquote>
<p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false</p>
</blockquote>
<p>语法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">valueToFind</span><span class="p">[,</span> <span class="nx">fromIndex</span><span class="p">])</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>valueToFind</code></p>
<p>需要查找的元素值。<strong>Note:</strong> 使用 <code>includes()</code>比较字符串和字符时是区分大小写。</p>
</li>
<li>
<p><code>fromIndex</code> 可选</p>
<p>从<code>fromIndex</code> 索引处开始查找 <code>valueToFind</code>。如果为负值，则按升序从 <code>array.length + fromIndex</code> 的索引开始搜 （即使从末尾开始往前跳 <code>fromIndex</code> 的绝对值个索引，然后往后搜寻）。默认为 0。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="kc">NaN</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="21find">21、<strong>find</strong></h4>
<blockquote>
<p><code>find() </code>方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <code>undefined</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">arr</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">callback</span><span class="p">[,</span> <span class="nx">thisArg</span><span class="p">])</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>callback</code></p>
<p>在数组每一项上执行的函数，接收 3 个参数：<code>element</code>当前遍历到的元素。<code>index</code>可选当前遍历到的索引。<code>array</code>可选数组本身</p>
</li>
<li>
<p><code>thisArg</code>可选</p>
<p>执行回调时用作 <code>this</code> 的对象</p>
</li>
</ul>
<h4 id="find-findindex-indexof--includes-filter">find findindex indexOf  includes filter</h4>
<h4 id="22hasownproperty">22、hasOwnProperty</h4>
<p><a href="https://juejin.cn/post/6966053301615853582">https://juejin.cn/post/6966053301615853582</a></p>
<blockquote>
<p><code>hasOwnProperty</code>是Object.prototype的一个方法
<strong>他能判断一个对象是否包含自定义属性而不是原型链上的属性</strong>
<code>hasOwnProperty</code> 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数</p>
</blockquote>
<img src="https://huyu-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220805205922244.png?x-oss-process=style/huyu" alt="image-20220805205922244" style="zoom:150%;" />
<h4 id="23js如何判断两个对象是否相等">23、JS如何判断两个对象是否相等</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;zs&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span><span class="o">:</span> <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">job</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sex</span><span class="o">:</span> <span class="s1">&#39;男&#39;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;zs&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span><span class="o">:</span> <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">job</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sex</span><span class="o">:</span> <span class="s1">&#39;男&#39;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="jsonstringify转字符串">JSON.stringify（）转字符串</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">===</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>  <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>缺陷</strong>：哪怕两个对象的内部数据相等，但只要每个数据对应的位置不同，其结果也为false</p>
<h6 id="函数检测">函数检测</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">isEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">aKeysList</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="kr">const</span> <span class="nx">bKeysList</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="nx">aKeysList</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">bKeysList</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">aKey</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">aKey</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">b</span><span class="p">[</span><span class="nx">aKey</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span>   <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>缺陷</strong>：若对象当中嵌有引用类型数据，则此方法则不适用，需要进行改进</p>
<h6 id="函数检测的基础上递归">函数检测的基础上递归</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">isEqual</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kr">const</span> <span class="nx">aKeysList</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kr">const</span> <span class="nx">bKeysList</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nx">aKeysList</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">bKeysList</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">aKey</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span><span class="p">[</span><span class="nx">aKey</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">b</span><span class="p">[</span><span class="nx">aKey</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">aKey</span><span class="p">],</span> <span class="nx">b</span><span class="p">[</span><span class="nx">aKey</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">aKey</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">b</span><span class="p">[</span><span class="nx">aKey</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">isEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span>  <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="24forin和forof的区别">24、for···in和for···of的区别</h4>
<p><a href="https://blog.csdn.net/weixin_43638968/article/details/109291957">https://blog.csdn.net/weixin_43638968/article/details/109291957</a></p>
<p><strong>首先一句话：(for···in取key，for··of取value)</strong>
①从遍历<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">数组</a>角度来说，for···in遍历出来的是key(即下标)，for···of遍历出来的是value(即数组的值)；</p>
<p>②从遍历<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020">字符串</a>的角度来说，同数组一样。</p>
<p>③从遍历对象的角度来说，for···in会遍历出来的为对象的key，但for···of会直接报错。</p>
<p>④如果要使用for…of遍历普通对象，需要配合Object.keys()一起使用。</p>
<h4 id="25创建对象的几种方式">25、创建对象的几种方式</h4>
<p><a href="https://juejin.cn/post/6844904126233444360">https://juejin.cn/post/6844904126233444360</a></p>
<h6 id="字面量">字面量</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="new-object">new Object</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="构造函数">构造函数</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span></span><span class="line"><span class="cl">	<span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sang</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;唱歌&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="mi">22</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="es6-class">ES6 class</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// constructor构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sayname</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//原型上的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">per</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;dz&#39;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="26变量提升与函数提升">26、变量提升与函数提升</h4>
<h6 id="变量提升">变量提升</h6>
<p>将变量声明提升到它所在作用域的最开始的部分。</p>
<ul>
<li><strong>通过var定义（声明）的变量，在定义语句之前就可以访问到</strong></li>
<li><strong>值：undefined；</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为有变量提升的缘故，上面代码实际的执行顺序为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h6 id="函数提升">函数提升</h6>
<blockquote>
<p>js中创建函数有两种方式：<strong>函数声明式</strong>和<strong>函数表达式</strong></p>
</blockquote>
<p><strong>1、函数声明提升</strong></p>
<p><strong>js在执行之前，会把foo函数提升到最前面</strong>，所以我们在fun函数定义之前就可以使用fun函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">	<span class="nx">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kd">function</span> <span class="nx">fun</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;aa&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打印结果为aa；说明以函数声明来定义函数时，可以在定义函数之前访问到定义的函数。</p>
<p><strong>2、函数表达式提升</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fun</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;函数表达式&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此种声明方式我们可以理解为<strong>一个普通变量的提升</strong>，在js代码执行之前会把fun提升带最前面，<strong>在函数赋值之前，fun是undefined，如果调用fun(),将会报错</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">	<span class="nx">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fun</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
</span></span><span class="line"><span class="cl">	    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;aa&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时打印的结果为报错<code>Uncaught TypeError: fun is not a function</code>，因为在js代码执行之前，会把fun提升到最前面，值为undefined，不是一个函数，以函数的形式来进行调用时将会报错。</p>
<h4 id="27暂时性死区">27、暂时性死区</h4>
<blockquote>
<p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，<strong>只有等到声明变量的那一行代码出现，才可以获取和使用该变量</strong></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">	<span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>   <span class="c1">// ReferenceError: Cannot access &#39;a&#39; before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">let</span><span class="err">/const a = 78</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fn</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="28es6新增了哪些语法">28、ES6新增了哪些语法</h4>
<blockquote>
<ul>
<li>class</li>
<li>箭头函数</li>
<li>解构赋值</li>
<li>字符串模板</li>
<li>async/await</li>
<li>引入 module 模块</li>
<li>generators(生成器)</li>
<li>Map和Set</li>
</ul>
</blockquote>
<h4 id="29假如有10万条数据需要处理前端应该怎么处理">29、假如有10万条数据需要处理，前端应该怎么处理？</h4>
<p><a href="https://juejin.cn/post/6844904184689475592">https://juejin.cn/post/6844904184689475592</a></p>
<p><a href="https://juejin.cn/post/7101206944534233125#heading-29">https://juejin.cn/post/7101206944534233125#heading-29</a></p>
<p>思路：</p>
<ol>
<li><strong>采用懒加载+分页(前端维护懒加载的数据分发和分页)</strong></li>
<li><strong>使用虚拟滚动技术(目前react的antd4.0已支持虚拟滚动的select长列表)</strong></li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">huyu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2022-02-09
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/js/">js</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/16.vue%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">vue知识总结</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%89%93%E5%8D%B0%E7%BB%84%E4%BB%B6/">
            <span class="next-text nav-default">打印组件</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/pan52yu" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>huyu</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








<script>
	function createCopyButton(highlightDiv) {
		const div = document.createElement("div");
		div.className = "copy-code";
		div.innerText = "Copy";
		div.addEventListener("click", () =>
			copyCodeToClipboard(div, highlightDiv)
		);
		addCopyButtonToDom(div, highlightDiv);
	}

	async function copyCodeToClipboard(button, highlightDiv) {
		const codeToCopy = highlightDiv.querySelector(":last-child > .chroma > code")
			.innerText;
		await navigator.clipboard.writeText(codeToCopy);
		button.blur();
		button.innerText = "Copied!";
		setTimeout(() => button.innerText = "Copy", 2000);
	}

	function addCopyButtonToDom(button, highlightDiv) {
		highlightDiv.insertBefore(button, highlightDiv.firstChild);
		const wrapper = document.createElement("div");
		wrapper.className = "highlight-wrapper";
		highlightDiv.parentNode.insertBefore(wrapper, highlightDiv);
		wrapper.appendChild(highlightDiv);
	}

	var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
	if(!isMobile){
		document.querySelectorAll(".highlight").forEach((highlightDiv) => createCopyButton(highlightDiv));
	}
</script>


</body>
</html>
